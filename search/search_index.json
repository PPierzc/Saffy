{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Saffy A High-Level Signal Analysis Framework Ever too often in signal analysis is time wasted on the repetitive tasks, which are very similar across projects. You promise yourself to build a code base for your solutions, but end up just copy pasting whole chunks of code. Starting each project you hope that this time you will have good structure and it will be awesome to work with. But it most often fails. Probably because your on a deadline or building sustainable data architectures is not your thing, you just wanted to do some analysis. Rightfully so! That's why saffy was created, so that you don't have to come up with a data structure and architecture. So that you can concentrate on the fun and important part which is the analysis! When you come up with a solution you like, you already have it as part of the framework, so it is easy to use in the future. Slack Channel - Github Check out how much code you can spare! Features Write 50% less code than before You concentrate on the fun logic stuff and let saffy do the boring repetetive tasks. Lost in variables and data? Saffy provides a data architecture to keep it clean. Quick prototyping of signal analysis algorithms Reproducibility of solutions Clean, readable and organized code Your code-base can easily expand over multiple projects A clean pipline from modeled signals to real-world data Less of that brain-less and repetitive work Install pip3 install saffy From Source !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master Usage import saffy sig = saffy.SignalManager(filename=\"path/to/file\") Example A short example of how to use saffy for EEG data analysis. EEG = saffy.SignalManager(filename=\"path/to/file\") EEG.extract_channels(['C3', 'C4', 'trig']) EEG.set_tags_from_channel('trig') EEG.remove_channel('trig') EEG.butter_highpass_filter(cutoff=1, order=2) EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop') PRE_EEG = EEG.copy('pre') PRE_EEG.set_epochs_from_tags(-4, -2) PRE_EEG.welch_mean_spectrum() POST_EEG = EEG.copy('post') POST_EEG.set_epochs_from_tags(0.5, 2.5) POST_EEG.welch_mean_spectrum() With just this code we managed to calculate the mean spectrum using Welch's method for the signal before and after the trigger. In plain numpy and scipy this would take much longer, would be less readable and probably would be much more error prone. For comparison you can see the attached solution in plain numpy and scipy. Contributing If you like the project and want to add something to it then please create a pull request. The title should shortly summarize the goal of your addition In the description go in depth with the changes you have made and why.","title":"Home"},{"location":"#saffy","text":"","title":"Saffy"},{"location":"#a-high-level-signal-analysis-framework","text":"Ever too often in signal analysis is time wasted on the repetitive tasks, which are very similar across projects. You promise yourself to build a code base for your solutions, but end up just copy pasting whole chunks of code. Starting each project you hope that this time you will have good structure and it will be awesome to work with. But it most often fails. Probably because your on a deadline or building sustainable data architectures is not your thing, you just wanted to do some analysis. Rightfully so! That's why saffy was created, so that you don't have to come up with a data structure and architecture. So that you can concentrate on the fun and important part which is the analysis! When you come up with a solution you like, you already have it as part of the framework, so it is easy to use in the future. Slack Channel - Github Check out how much code you can spare!","title":"A High-Level Signal Analysis Framework"},{"location":"#features","text":"Write 50% less code than before You concentrate on the fun logic stuff and let saffy do the boring repetetive tasks. Lost in variables and data? Saffy provides a data architecture to keep it clean. Quick prototyping of signal analysis algorithms Reproducibility of solutions Clean, readable and organized code Your code-base can easily expand over multiple projects A clean pipline from modeled signals to real-world data Less of that brain-less and repetitive work","title":"Features"},{"location":"#install","text":"pip3 install saffy","title":"Install"},{"location":"#from-source","text":"!pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master","title":"From Source"},{"location":"#usage","text":"import saffy sig = saffy.SignalManager(filename=\"path/to/file\")","title":"Usage"},{"location":"#example","text":"A short example of how to use saffy for EEG data analysis. EEG = saffy.SignalManager(filename=\"path/to/file\") EEG.extract_channels(['C3', 'C4', 'trig']) EEG.set_tags_from_channel('trig') EEG.remove_channel('trig') EEG.butter_highpass_filter(cutoff=1, order=2) EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop') PRE_EEG = EEG.copy('pre') PRE_EEG.set_epochs_from_tags(-4, -2) PRE_EEG.welch_mean_spectrum() POST_EEG = EEG.copy('post') POST_EEG.set_epochs_from_tags(0.5, 2.5) POST_EEG.welch_mean_spectrum() With just this code we managed to calculate the mean spectrum using Welch's method for the signal before and after the trigger. In plain numpy and scipy this would take much longer, would be less readable and probably would be much more error prone. For comparison you can see the attached solution in plain numpy and scipy.","title":"Example"},{"location":"#contributing","text":"If you like the project and want to add something to it then please create a pull request. The title should shortly summarize the goal of your addition In the description go in depth with the changes you have made and why.","title":"Contributing"},{"location":"SignalManager/","text":"SignalManager The SignalManager comes with some basic parameters. field description fs sampling frequency num_channels number of channels channel_names name for each channel data the signal in the structure of (epoch x channel x signal) t time vector epochs number of epochs tags position of tags in signal spectrum matrix of spectrum spectrum_freqs vector of frequencies phase matrix of phase history a list of all the steps taken When initializing the object there are two options. Generator A dictionary of the structure data = { 'fs': # float, 'num_channels': # integer, 'channel_names': # list of strings, 'epochs': # integer, 't': # time array, 'tags': # list, 'data': # Signal Matrix } saffy.SignalManager(generator=data) Filename The name of the file generated by Svarog. 3 files eg. data.raw , data.xml , data.tag saffy.SignalManager(filename='data') set_tags_from_channel(self, channel_name) Uses a channel as the tag indicator. Normalizes the value to 1 through divided by the maximum value. Sets threshold at 0.9. Sets tag at beginnings of resultant clusters. Params channel_name : the string name of the channel to set tags from. set_epochs_from_tags(self, low, high) Uses the tag list to cut the data into epochs. The low and high tell us where to cut based on the tags. They are in seconds. For example if you want to cut between 2 seconds before and 3 after the tag you would write sig.set_epochs_from_tags(-2, 3) . Params low : In seconds. Starting time of the epoch relative to the tag. The tag is 0 seconds. high : In seconds. Ending time of the epoch relative to the tag. The tag is 0 seconds. remove_channels(self, channel_names) Removes the specified channels from the data. Params channel_names : list of strings extract_channels(self, channel_names) Removes all channels except for those provided in the channel_names parameter. Params channel_names : list of strings extract_time_range(self, low, high) Cuts data to the provided low and high arguments. Params low : starting point of new signal in seconds. high : end point of new signal in seconds. copy(self, name=\"\") Creates a independent copy of the SignalManager object. Params name : a documenting value to keep track why we are coping the signal. call(self, func) Used to run single custom functions on the data. Allows consistency when building analysis piplines. Params func : a function that takes only self as the parameter. Example You should do this: def custom_function(self): print(self.data) sig.call(custom_function) instead of this: def custom_function(sig): print(sig.data) custom_function(sig) register_plugin(cls, plugin) Use this to add a custom plugin to be used with the SignalManager Params plugin : An instance of the PluginManager class. Example Create a custom plugin. class CustomPlugin(saffy.PluginManager): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.custom = { 'param': 'some value' } def custom_function(self): # do something pass Then you can regiser it and use the custom_function . saffy.SignalManager.register_plugin(CustomPlugin) History All the operations on the signal are stored in the history parameter. It allows to keep track of the changes that have been made to the signal. Chaining Each method returns self, so chaining of functions is possible. For example setting tags could be done this way. sig = SignalManager(filename='path/to/file')\\ .extract_channels(['C3', 'C4', 'trig'])\\ .set_tags_from_channel('trig')\\ .remove_channel('trig')","title":"SignalManager"},{"location":"SignalManager/#signalmanager","text":"The SignalManager comes with some basic parameters. field description fs sampling frequency num_channels number of channels channel_names name for each channel data the signal in the structure of (epoch x channel x signal) t time vector epochs number of epochs tags position of tags in signal spectrum matrix of spectrum spectrum_freqs vector of frequencies phase matrix of phase history a list of all the steps taken When initializing the object there are two options.","title":"SignalManager"},{"location":"SignalManager/#generator","text":"A dictionary of the structure data = { 'fs': # float, 'num_channels': # integer, 'channel_names': # list of strings, 'epochs': # integer, 't': # time array, 'tags': # list, 'data': # Signal Matrix } saffy.SignalManager(generator=data)","title":"Generator"},{"location":"SignalManager/#filename","text":"The name of the file generated by Svarog. 3 files eg. data.raw , data.xml , data.tag saffy.SignalManager(filename='data')","title":"Filename"},{"location":"SignalManager/#set_tags_from_channelself-channel_name","text":"Uses a channel as the tag indicator. Normalizes the value to 1 through divided by the maximum value. Sets threshold at 0.9. Sets tag at beginnings of resultant clusters.","title":"set_tags_from_channel(self, channel_name)"},{"location":"SignalManager/#params","text":"channel_name : the string name of the channel to set tags from.","title":"Params"},{"location":"SignalManager/#set_epochs_from_tagsself-low-high","text":"Uses the tag list to cut the data into epochs. The low and high tell us where to cut based on the tags. They are in seconds. For example if you want to cut between 2 seconds before and 3 after the tag you would write sig.set_epochs_from_tags(-2, 3) .","title":"set_epochs_from_tags(self, low, high)"},{"location":"SignalManager/#params_1","text":"low : In seconds. Starting time of the epoch relative to the tag. The tag is 0 seconds. high : In seconds. Ending time of the epoch relative to the tag. The tag is 0 seconds.","title":"Params"},{"location":"SignalManager/#remove_channelsself-channel_names","text":"Removes the specified channels from the data.","title":"remove_channels(self, channel_names)"},{"location":"SignalManager/#params_2","text":"channel_names : list of strings","title":"Params"},{"location":"SignalManager/#extract_channelsself-channel_names","text":"Removes all channels except for those provided in the channel_names parameter.","title":"extract_channels(self, channel_names)"},{"location":"SignalManager/#params_3","text":"channel_names : list of strings","title":"Params"},{"location":"SignalManager/#extract_time_rangeself-low-high","text":"Cuts data to the provided low and high arguments.","title":"extract_time_range(self, low, high)"},{"location":"SignalManager/#params_4","text":"low : starting point of new signal in seconds. high : end point of new signal in seconds.","title":"Params"},{"location":"SignalManager/#copyself-name","text":"Creates a independent copy of the SignalManager object.","title":"copy(self, name=\"\")"},{"location":"SignalManager/#params_5","text":"name : a documenting value to keep track why we are coping the signal.","title":"Params"},{"location":"SignalManager/#callself-func","text":"Used to run single custom functions on the data. Allows consistency when building analysis piplines.","title":"call(self, func)"},{"location":"SignalManager/#params_6","text":"func : a function that takes only self as the parameter.","title":"Params"},{"location":"SignalManager/#example","text":"You should do this: def custom_function(self): print(self.data) sig.call(custom_function) instead of this: def custom_function(sig): print(sig.data) custom_function(sig)","title":"Example"},{"location":"SignalManager/#register_plugincls-plugin","text":"Use this to add a custom plugin to be used with the SignalManager","title":"register_plugin(cls, plugin)"},{"location":"SignalManager/#params_7","text":"plugin : An instance of the PluginManager class.","title":"Params"},{"location":"SignalManager/#example_1","text":"Create a custom plugin. class CustomPlugin(saffy.PluginManager): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.custom = { 'param': 'some value' } def custom_function(self): # do something pass Then you can regiser it and use the custom_function . saffy.SignalManager.register_plugin(CustomPlugin)","title":"Example"},{"location":"SignalManager/#history","text":"All the operations on the signal are stored in the history parameter. It allows to keep track of the changes that have been made to the signal.","title":"History"},{"location":"SignalManager/#chaining","text":"Each method returns self, so chaining of functions is possible. For example setting tags could be done this way. sig = SignalManager(filename='path/to/file')\\ .extract_channels(['C3', 'C4', 'trig'])\\ .set_tags_from_channel('trig')\\ .remove_channel('trig')","title":"Chaining"},{"location":"Plugins/Create Custom Plugins/","text":"Create Custom Plugin There will most definitely be a case, where you will want to create a custom plugin. The proposed convention for plugin development is the following. All data that is to be stored extra, should be stored in the form of a dictionary assigned to a variable of the same name as the plugin. Plugin functions should be preceded by the plugin name. Class Implementation import saffy class CustomPlugin(saffy.PluginManager): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.custom = { 'param': 'some value' } def custom_function(self): # do something pass saffy.SignalManager.register_plugin(CustomPlugin) sig = saffy.SignalManager(generator=signal_data) sig.custom_function() Functional Plugin In other cases when it is only one function you want to use you can use the call function sig = saffy.SignalManager(generator=signal_data) def custom_function(self): print(self.data) sig.call(custom_function)","title":"Create Custom Plugins"},{"location":"Plugins/Create Custom Plugins/#create-custom-plugin","text":"There will most definitely be a case, where you will want to create a custom plugin. The proposed convention for plugin development is the following. All data that is to be stored extra, should be stored in the form of a dictionary assigned to a variable of the same name as the plugin. Plugin functions should be preceded by the plugin name.","title":"Create Custom Plugin"},{"location":"Plugins/Create Custom Plugins/#class-implementation","text":"import saffy class CustomPlugin(saffy.PluginManager): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.custom = { 'param': 'some value' } def custom_function(self): # do something pass saffy.SignalManager.register_plugin(CustomPlugin) sig = saffy.SignalManager(generator=signal_data) sig.custom_function()","title":"Class Implementation"},{"location":"Plugins/Create Custom Plugins/#functional-plugin","text":"In other cases when it is only one function you want to use you can use the call function sig = saffy.SignalManager(generator=signal_data) def custom_function(self): print(self.data) sig.call(custom_function)","title":"Functional Plugin"},{"location":"Plugins/Filters/","text":"Filters A set of filter designs to simplify the process of filtering data. cheb2_notch_filter(self, cutoff, order=5, rs=3, width=.1, method=None, btype='bandstop') A notch filter using the cheby2 filter from scipy. Params cutoff : The frequency at which the filter is to act. order : The order of the filter rs : Minimum attenuation required in stop band. Specified in decibels. width : How precise is the filter supposed to be. In Hz. method : Method of filtering. By default scipy.signal.filtfilt is used btype : Type of filter bandstop or bandpass butter_highpass_filter(self, cutoff, order=5, method=None) A highpass filter filter using the butterworth filter from scipy. Params cutoff : The frequency at which the filter is to act. order : The order of the filter method : Method of filtering. By default scipy.signal.filtfilt is used butter_lowpass_filter(self, cutoff, order=5, method=None) A lowpass filter filter using the butterworth filter from scipy. Params cutoff : The frequency at which the filter is to act. order : The order of the filter method : Method of filtering. By default scipy.signal.filtfilt is used butter_bandpass_filter(self, lowcut, highcut, order=5, method=None) A bandpass filter filter using the butterworth filter from scipy. Params lowcut : The lower frequency at which the filter is to act. highcut : The higher frequency at which the filter is to act. order : The order of the filter method : Method of filtering. By default scipy.signal.filtfilt is used","title":"Filters"},{"location":"Plugins/Filters/#filters","text":"A set of filter designs to simplify the process of filtering data.","title":"Filters"},{"location":"Plugins/Filters/#cheb2_notch_filterself-cutoff-order5-rs3-width1-methodnone-btypebandstop","text":"A notch filter using the cheby2 filter from scipy.","title":"cheb2_notch_filter(self, cutoff, order=5, rs=3, width=.1, method=None, btype='bandstop')"},{"location":"Plugins/Filters/#params","text":"cutoff : The frequency at which the filter is to act. order : The order of the filter rs : Minimum attenuation required in stop band. Specified in decibels. width : How precise is the filter supposed to be. In Hz. method : Method of filtering. By default scipy.signal.filtfilt is used btype : Type of filter bandstop or bandpass","title":"Params"},{"location":"Plugins/Filters/#butter_highpass_filterself-cutoff-order5-methodnone","text":"A highpass filter filter using the butterworth filter from scipy.","title":"butter_highpass_filter(self, cutoff, order=5, method=None)"},{"location":"Plugins/Filters/#params_1","text":"cutoff : The frequency at which the filter is to act. order : The order of the filter method : Method of filtering. By default scipy.signal.filtfilt is used","title":"Params"},{"location":"Plugins/Filters/#butter_lowpass_filterself-cutoff-order5-methodnone","text":"A lowpass filter filter using the butterworth filter from scipy.","title":"butter_lowpass_filter(self, cutoff, order=5, method=None)"},{"location":"Plugins/Filters/#params_2","text":"cutoff : The frequency at which the filter is to act. order : The order of the filter method : Method of filtering. By default scipy.signal.filtfilt is used","title":"Params"},{"location":"Plugins/Filters/#butter_bandpass_filterself-lowcut-highcut-order5-methodnone","text":"A bandpass filter filter using the butterworth filter from scipy.","title":"butter_bandpass_filter(self, lowcut, highcut, order=5, method=None)"},{"location":"Plugins/Filters/#params_3","text":"lowcut : The lower frequency at which the filter is to act. highcut : The higher frequency at which the filter is to act. order : The order of the filter method : Method of filtering. By default scipy.signal.filtfilt is used","title":"Params"},{"location":"Plugins/Fourier/","text":"Fourier The classical method for calculating the spectral density. fourier_transform(self) Calculates the real fast fourier transform. Sets the values of self.spectrum and self.spectrum_freqs , self.phase .","title":"Fourier"},{"location":"Plugins/Fourier/#fourier","text":"The classical method for calculating the spectral density.","title":"Fourier"},{"location":"Plugins/Fourier/#fourier_transformself","text":"Calculates the real fast fourier transform. Sets the values of self.spectrum and self.spectrum_freqs , self.phase .","title":"fourier_transform(self)"},{"location":"Plugins/Graphics/","text":"Graphics Simple graphing functions to show the basic info about the signal graphics_spectrum_plot(self, fig, ax, title='', color='#ff0641', args, *kwargs) Plots the value of the calculated spectrum for each channel on a separate subplot. Params fig : A matplotlib figure object ax : A matplotlib axis object. There must be the same amount of axies as channels. title : The figure title color : The color of the figure plot args & kwargs : Other arguments to the matplotlib.pyplot.plot function Example sig.fourier_transform() fig, ax = plt.subplots(nrows=sig.num_channels, ncols=1) sig.graphics_spectrum_plot(fig, ax, 'Custom Title', alpha=0.3) plt.show() plt.close() graphics_time_plot(self, fig, ax, title='', color='#ff0641', args, *kwargs) Plots the value of the data for each channel on a separate subplot. Params fig : A matplotlib figure object ax : A matplotlib axis object title : The figure title color : The color of the figure plot args & kwargs : Other arguments to the matplotlib.pyplot.plot function Example fig, ax = plt.subplots(nrows=sig.num_channels, ncols=1) sig.graphics_time_plot(fig, ax, 'Custom Title', alpha=0.3) plt.show() plt.close()","title":"Graphics"},{"location":"Plugins/Graphics/#graphics","text":"Simple graphing functions to show the basic info about the signal","title":"Graphics"},{"location":"Plugins/Graphics/#graphics_spectrum_plotself-fig-ax-title-colorff0641-args-kwargs","text":"Plots the value of the calculated spectrum for each channel on a separate subplot.","title":"graphics_spectrum_plot(self, fig, ax, title='', color='#ff0641', args, *kwargs)"},{"location":"Plugins/Graphics/#params","text":"fig : A matplotlib figure object ax : A matplotlib axis object. There must be the same amount of axies as channels. title : The figure title color : The color of the figure plot args & kwargs : Other arguments to the matplotlib.pyplot.plot function","title":"Params"},{"location":"Plugins/Graphics/#example","text":"sig.fourier_transform() fig, ax = plt.subplots(nrows=sig.num_channels, ncols=1) sig.graphics_spectrum_plot(fig, ax, 'Custom Title', alpha=0.3) plt.show() plt.close()","title":"Example"},{"location":"Plugins/Graphics/#graphics_time_plotself-fig-ax-title-colorff0641-args-kwargs","text":"Plots the value of the data for each channel on a separate subplot.","title":"graphics_time_plot(self, fig, ax, title='', color='#ff0641', args, *kwargs)"},{"location":"Plugins/Graphics/#params_1","text":"fig : A matplotlib figure object ax : A matplotlib axis object title : The figure title color : The color of the figure plot args & kwargs : Other arguments to the matplotlib.pyplot.plot function","title":"Params"},{"location":"Plugins/Graphics/#example_1","text":"fig, ax = plt.subplots(nrows=sig.num_channels, ncols=1) sig.graphics_time_plot(fig, ax, 'Custom Title', alpha=0.3) plt.show() plt.close()","title":"Example"},{"location":"Plugins/Hilbert/","text":"Hilbert The plugin for calculating Hilbert Transform hilbert: dict The data structure which stores all the calculated values, like the power, amplitude, phase. field description data hilbert transform amplitude the instantaneous amplitude power the instantaneous power phase the instantaneous phase hilbert_transform(self, phase_freq=0) Calculates the Hilbert Transform. The phase_freq is used to determine for which frequency is the instantaneous phase to be calculated. It populates all the values of the hilbert dictionary. Params phase_freq : when calculating the instantaneous phase, we need to know for which frequency to calculate it. hilbert_subtract_base(self, low, high) Calculates the mean power from the power between low and high , then subtracts the mean value from the entire power vector. Calculates for each channel separately. Params low : the start time (in seconds) from where to calculate the mean. high : the end time (in seconds) from where to calculate the mean. hilbert_mean_power(self) Calculates the mean power across epochs.","title":"Hilbert"},{"location":"Plugins/Hilbert/#hilbert","text":"The plugin for calculating Hilbert Transform","title":"Hilbert"},{"location":"Plugins/Hilbert/#hilbert-dict","text":"The data structure which stores all the calculated values, like the power, amplitude, phase. field description data hilbert transform amplitude the instantaneous amplitude power the instantaneous power phase the instantaneous phase","title":"hilbert: dict"},{"location":"Plugins/Hilbert/#hilbert_transformself-phase_freq0","text":"Calculates the Hilbert Transform. The phase_freq is used to determine for which frequency is the instantaneous phase to be calculated. It populates all the values of the hilbert dictionary.","title":"hilbert_transform(self, phase_freq=0)"},{"location":"Plugins/Hilbert/#params","text":"phase_freq : when calculating the instantaneous phase, we need to know for which frequency to calculate it.","title":"Params"},{"location":"Plugins/Hilbert/#hilbert_subtract_baseself-low-high","text":"Calculates the mean power from the power between low and high , then subtracts the mean value from the entire power vector. Calculates for each channel separately.","title":"hilbert_subtract_base(self, low, high)"},{"location":"Plugins/Hilbert/#params_1","text":"low : the start time (in seconds) from where to calculate the mean. high : the end time (in seconds) from where to calculate the mean.","title":"Params"},{"location":"Plugins/Hilbert/#hilbert_mean_powerself","text":"Calculates the mean power across epochs.","title":"hilbert_mean_power(self)"},{"location":"Plugins/PluginManager/","text":"PluginManager The plugin manager is just a template class for developing plugins. It provides the necessary basic params to the plugins.","title":"PluginManager"},{"location":"Plugins/PluginManager/#pluginmanager","text":"The plugin manager is just a template class for developing plugins. It provides the necessary basic params to the plugins.","title":"PluginManager"},{"location":"Plugins/Welch/","text":"Welch Is one of the methods for calculating the spectral density. welch_spectrum(self) Calculates the Welch spectrum. Adds the values to self.spectrum and self.spectrum_freqs . welch_mean_spectrum(self) Calculates the Welch spectrum and then takes the mean value across epochs. Adds the values to self.spectrum and self.spectrum_freqs","title":"Welch"},{"location":"Plugins/Welch/#welch","text":"Is one of the methods for calculating the spectral density.","title":"Welch"},{"location":"Plugins/Welch/#welch_spectrumself","text":"Calculates the Welch spectrum. Adds the values to self.spectrum and self.spectrum_freqs .","title":"welch_spectrum(self)"},{"location":"Plugins/Welch/#welch_mean_spectrumself","text":"Calculates the Welch spectrum and then takes the mean value across epochs. Adds the values to self.spectrum and self.spectrum_freqs","title":"welch_mean_spectrum(self)"},{"location":"Tutorials/Basics/","text":"Tutorial: Basics An introductory tutorial to get you familiar with how easy it is to do analysis with saffy. Setup First we need to install the package using pip pip3 install saffy Loading some data We first need to generate our data. For that we will use the built in generator simple_sine_generator . How generators work will be discussed in a later tutorial for now let's concentrate on the latter parts. import saffy sig = saffy.SignalManager(generator=saffy.generators.simple_sine_generator(10, 0, 1, 128)) We now have a sine signal of 10 Hz frequency, 0 phase shift, 1 second long and a sampling rate of 128. We can now easily plot the signal and see what was loaded in. Basic time plotting sig.graphics_time_plot() Basic spectral plotting Now let's calculate the real Fourier transform and plot the spectrum. sig.fourier_transform() sig.graphics_spectrum_plot() And that is it you have done some basic Fourier signal analysis.","title":"Basics"},{"location":"Tutorials/Basics/#tutorial-basics","text":"An introductory tutorial to get you familiar with how easy it is to do analysis with saffy.","title":"Tutorial: Basics"},{"location":"Tutorials/Basics/#setup","text":"First we need to install the package using pip pip3 install saffy","title":"Setup"},{"location":"Tutorials/Basics/#loading-some-data","text":"We first need to generate our data. For that we will use the built in generator simple_sine_generator . How generators work will be discussed in a later tutorial for now let's concentrate on the latter parts. import saffy sig = saffy.SignalManager(generator=saffy.generators.simple_sine_generator(10, 0, 1, 128)) We now have a sine signal of 10 Hz frequency, 0 phase shift, 1 second long and a sampling rate of 128. We can now easily plot the signal and see what was loaded in.","title":"Loading some data"},{"location":"Tutorials/Basics/#basic-time-plotting","text":"sig.graphics_time_plot()","title":"Basic time plotting"},{"location":"Tutorials/Basics/#basic-spectral-plotting","text":"Now let's calculate the real Fourier transform and plot the spectrum. sig.fourier_transform() sig.graphics_spectrum_plot() And that is it you have done some basic Fourier signal analysis.","title":"Basic spectral plotting"},{"location":"Tutorials/custom_generators/","text":"Tutorial: Custom Generators In the last tutorial we used a generator to provide us some data to work with. Now we will look at what it takes to create a custom generator. Simple Sine Generator. We will first start off with writing a simple sine wave generator. We will build a single epoch and single channeled sine wave. def sine_wave_generator(frequency, phase, length, sampling_rate): data = { 'fs': sampling_rate, 'num_channels': 1, 'channel_names': ['sine'], 'epochs': 1 } We first need to define our data holding dictionary. It is the constructing element of our signal. Let's add the sine function itself. The data dictionary can hold any of the values specified in the SignalManger documentation. The next step is to add the signal itself. This is done in the classical way like you would normally create a sine wave. import numpy as np def sine_wave_generator(frequency, phase, length, sampling_rate): data = { 'fs': sampling_rate, 'num_channels': 1, 'channel_names': ['sine'], 'epochs': 1 } data['t'] = np.arange(0, length, 1 / data['fs']) data['data'] = np.sin(2 * np.pi * frequency * data['t'] + phase) data['data'] = np.reshape(data['data'], (data['epochs'], data['num_channels'], *data['data'].shape)) return data And this set's us up. We first created the time vector and then from the definition of a sine wave we created, the data variable. We need to reshape the data however to account for the number of epochs and channels. We have to then return it so that the SignalManager will be able to read the specifications of our signal. With this principle you can load in any format of data you will need.","title":"Custom Generators"},{"location":"Tutorials/custom_generators/#tutorial-custom-generators","text":"In the last tutorial we used a generator to provide us some data to work with. Now we will look at what it takes to create a custom generator.","title":"Tutorial: Custom Generators"},{"location":"Tutorials/custom_generators/#simple-sine-generator","text":"We will first start off with writing a simple sine wave generator. We will build a single epoch and single channeled sine wave. def sine_wave_generator(frequency, phase, length, sampling_rate): data = { 'fs': sampling_rate, 'num_channels': 1, 'channel_names': ['sine'], 'epochs': 1 } We first need to define our data holding dictionary. It is the constructing element of our signal. Let's add the sine function itself. The data dictionary can hold any of the values specified in the SignalManger documentation. The next step is to add the signal itself. This is done in the classical way like you would normally create a sine wave. import numpy as np def sine_wave_generator(frequency, phase, length, sampling_rate): data = { 'fs': sampling_rate, 'num_channels': 1, 'channel_names': ['sine'], 'epochs': 1 } data['t'] = np.arange(0, length, 1 / data['fs']) data['data'] = np.sin(2 * np.pi * frequency * data['t'] + phase) data['data'] = np.reshape(data['data'], (data['epochs'], data['num_channels'], *data['data'].shape)) return data And this set's us up. We first created the time vector and then from the definition of a sine wave we created, the data variable. We need to reshape the data however to account for the number of epochs and channels. We have to then return it so that the SignalManager will be able to read the specifications of our signal. With this principle you can load in any format of data you will need.","title":"Simple Sine Generator."}]}